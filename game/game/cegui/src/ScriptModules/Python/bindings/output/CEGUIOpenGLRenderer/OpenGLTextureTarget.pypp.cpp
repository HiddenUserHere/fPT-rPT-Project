// This file has been generated by Py++.

#include "boost/python.hpp"
#include "generators/include/python_CEGUIOpenGLRenderer.h"
#include "OpenGLTextureTarget.pypp.hpp"

namespace bp = boost::python;

struct OpenGLTextureTarget_wrapper : CEGUI::OpenGLTextureTarget, bp::wrapper< CEGUI::OpenGLTextureTarget > {

    OpenGLTextureTarget_wrapper(::CEGUI::OpenGLRendererBase & owner )
    : CEGUI::OpenGLTextureTarget( boost::ref(owner) )
      , bp::wrapper< CEGUI::OpenGLTextureTarget >(){
        // constructor
    
    }

    void createCEGUITexture(  ){
        CEGUI::OpenGLTextureTarget::createCEGUITexture(  );
    }

    static ::CEGUI::String generateTextureName(  ){
        return CEGUI::OpenGLTextureTarget::generateTextureName(  );
    }

    virtual void grabTexture(  ) {
        if( bp::override func_grabTexture = this->get_override( "grabTexture" ) )
            func_grabTexture(  );
        else{
            this->CEGUI::OpenGLTextureTarget::grabTexture(  );
        }
    }
    
    void default_grabTexture(  ) {
        CEGUI::OpenGLTextureTarget::grabTexture( );
    }

    virtual bool isImageryCache(  ) const  {
        if( bp::override func_isImageryCache = this->get_override( "isImageryCache" ) )
            return func_isImageryCache(  );
        else{
            return this->CEGUI::OpenGLTextureTarget::isImageryCache(  );
        }
    }
    
    bool default_isImageryCache(  ) const  {
        return CEGUI::OpenGLTextureTarget::isImageryCache( );
    }

    virtual bool isRenderingInverted(  ) const  {
        if( bp::override func_isRenderingInverted = this->get_override( "isRenderingInverted" ) )
            return func_isRenderingInverted(  );
        else{
            return this->CEGUI::OpenGLTextureTarget::isRenderingInverted(  );
        }
    }
    
    bool default_isRenderingInverted(  ) const  {
        return CEGUI::OpenGLTextureTarget::isRenderingInverted( );
    }

    virtual void restoreTexture(  ) {
        if( bp::override func_restoreTexture = this->get_override( "restoreTexture" ) )
            func_restoreTexture(  );
        else{
            this->CEGUI::OpenGLTextureTarget::restoreTexture(  );
        }
    }
    
    void default_restoreTexture(  ) {
        CEGUI::OpenGLTextureTarget::restoreTexture( );
    }

    virtual void clear(  ){
        bp::override func_clear = this->get_override( "clear" );
        func_clear(  );
    }

    virtual void declareRenderSize( ::CEGUI::Sizef const & sz ){
        bp::override func_declareRenderSize = this->get_override( "declareRenderSize" );
        func_declareRenderSize( boost::ref(sz) );
    }

};

void register_OpenGLTextureTarget_class(){

    { //::CEGUI::OpenGLTextureTarget
        typedef bp::class_< OpenGLTextureTarget_wrapper, boost::noncopyable > OpenGLTextureTarget_exposer_t;
        OpenGLTextureTarget_exposer_t OpenGLTextureTarget_exposer = OpenGLTextureTarget_exposer_t( "OpenGLTextureTarget", "*!\n\
        \n\
            OpenGLTextureTarget - Common base class for all OpenGL render targets\n\
            based on some form of RTT support.\n\
        *\n", bp::init< CEGUI::OpenGLRendererBase & >(( bp::arg("owner") ), "! constructor.\n") );
        bp::scope OpenGLTextureTarget_scope( OpenGLTextureTarget_exposer );
        { //::CEGUI::OpenGLTextureTarget::createCEGUITexture
        
            typedef void ( OpenGLTextureTarget_wrapper::*createCEGUITexture_function_type )(  ) ;
            
            OpenGLTextureTarget_exposer.def( 
                "createCEGUITexture"
                , createCEGUITexture_function_type( &OpenGLTextureTarget_wrapper::createCEGUITexture )
                , "! helper to create CEGUI.Texture d_CEGUITexture;\n" );
        
        }
        { //::CEGUI::OpenGLTextureTarget::generateTextureName
        
            typedef ::CEGUI::String ( *generateTextureName_function_type )(  );
            
            OpenGLTextureTarget_exposer.def( 
                "generateTextureName"
                , generateTextureName_function_type( &OpenGLTextureTarget_wrapper::generateTextureName )
                , "! helper to generate unique texture names\n" );
        
        }
        { //::CEGUI::OpenGLTextureTarget::getTexture
        
            typedef ::CEGUI::Texture & ( ::CEGUI::OpenGLTextureTarget::*getTexture_function_type )(  ) const;
            
            OpenGLTextureTarget_exposer.def( 
                "getTexture"
                , getTexture_function_type(&::CEGUI::OpenGLTextureTarget::getTexture)
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::CEGUI::OpenGLTextureTarget::grabTexture
        
            typedef void ( ::CEGUI::OpenGLTextureTarget::*grabTexture_function_type )(  ) ;
            typedef void ( OpenGLTextureTarget_wrapper::*default_grabTexture_function_type )(  ) ;
            
            OpenGLTextureTarget_exposer.def( 
                "grabTexture"
                , grabTexture_function_type(&::CEGUI::OpenGLTextureTarget::grabTexture)
                , default_grabTexture_function_type(&OpenGLTextureTarget_wrapper::default_grabTexture) );
        
        }
        { //::CEGUI::OpenGLTextureTarget::isImageryCache
        
            typedef bool ( ::CEGUI::OpenGLTextureTarget::*isImageryCache_function_type )(  ) const;
            typedef bool ( OpenGLTextureTarget_wrapper::*default_isImageryCache_function_type )(  ) const;
            
            OpenGLTextureTarget_exposer.def( 
                "isImageryCache"
                , isImageryCache_function_type(&::CEGUI::OpenGLTextureTarget::isImageryCache)
                , default_isImageryCache_function_type(&OpenGLTextureTarget_wrapper::default_isImageryCache) );
        
        }
        { //::CEGUI::OpenGLTextureTarget::isRenderingInverted
        
            typedef bool ( ::CEGUI::OpenGLTextureTarget::*isRenderingInverted_function_type )(  ) const;
            typedef bool ( OpenGLTextureTarget_wrapper::*default_isRenderingInverted_function_type )(  ) const;
            
            OpenGLTextureTarget_exposer.def( 
                "isRenderingInverted"
                , isRenderingInverted_function_type(&::CEGUI::OpenGLTextureTarget::isRenderingInverted)
                , default_isRenderingInverted_function_type(&OpenGLTextureTarget_wrapper::default_isRenderingInverted) );
        
        }
        { //::CEGUI::OpenGLTextureTarget::restoreTexture
        
            typedef void ( ::CEGUI::OpenGLTextureTarget::*restoreTexture_function_type )(  ) ;
            typedef void ( OpenGLTextureTarget_wrapper::*default_restoreTexture_function_type )(  ) ;
            
            OpenGLTextureTarget_exposer.def( 
                "restoreTexture"
                , restoreTexture_function_type(&::CEGUI::OpenGLTextureTarget::restoreTexture)
                , default_restoreTexture_function_type(&OpenGLTextureTarget_wrapper::default_restoreTexture) );
        
        }
        OpenGLTextureTarget_exposer.staticmethod( "generateTextureName" );
    }

}
