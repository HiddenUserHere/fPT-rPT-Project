// This file has been generated by Py++.

#include "boost/python.hpp"
#include "generators/include/python_CEGUI.h"
#include "XMLParser.pypp.hpp"

namespace bp = boost::python;

struct XMLParser_wrapper : CEGUI::XMLParser, bp::wrapper< CEGUI::XMLParser > {

    XMLParser_wrapper( )
    : CEGUI::XMLParser( )
      , bp::wrapper< CEGUI::XMLParser >(){
        // null constructor
    
    }

    virtual void cleanupImpl(  ){
        bp::override func_cleanupImpl = this->get_override( "cleanupImpl" );
        func_cleanupImpl(  );
    }

    virtual bool initialiseImpl(  ){
        bp::override func_initialiseImpl = this->get_override( "initialiseImpl" );
        return func_initialiseImpl(  );
    }

    virtual void parseXML( ::CEGUI::XMLHandler & handler, ::CEGUI::RawDataContainer const & source, ::CEGUI::String const & schemaName ){
        bp::override func_parseXML = this->get_override( "parseXML" );
        func_parseXML( boost::ref(handler), boost::ref(source), boost::ref(schemaName) );
    }

    virtual void parseXMLFile( ::CEGUI::XMLHandler & handler, ::CEGUI::String const & filename, ::CEGUI::String const & schemaName, ::CEGUI::String const & resourceGroup ) {
        if( bp::override func_parseXMLFile = this->get_override( "parseXMLFile" ) )
            func_parseXMLFile( boost::ref(handler), boost::ref(filename), boost::ref(schemaName), boost::ref(resourceGroup) );
        else{
            this->CEGUI::XMLParser::parseXMLFile( boost::ref(handler), boost::ref(filename), boost::ref(schemaName), boost::ref(resourceGroup) );
        }
    }
    
    void default_parseXMLFile( ::CEGUI::XMLHandler & handler, ::CEGUI::String const & filename, ::CEGUI::String const & schemaName, ::CEGUI::String const & resourceGroup ) {
        CEGUI::XMLParser::parseXMLFile( boost::ref(handler), boost::ref(filename), boost::ref(schemaName), boost::ref(resourceGroup) );
    }

    virtual void parseXMLString( ::CEGUI::XMLHandler & handler, ::CEGUI::String const & source, ::CEGUI::String const & schemaName ) {
        if( bp::override func_parseXMLString = this->get_override( "parseXMLString" ) )
            func_parseXMLString( boost::ref(handler), boost::ref(source), boost::ref(schemaName) );
        else{
            this->CEGUI::XMLParser::parseXMLString( boost::ref(handler), boost::ref(source), boost::ref(schemaName) );
        }
    }
    
    void default_parseXMLString( ::CEGUI::XMLHandler & handler, ::CEGUI::String const & source, ::CEGUI::String const & schemaName ) {
        CEGUI::XMLParser::parseXMLString( boost::ref(handler), boost::ref(source), boost::ref(schemaName) );
    }

};

void register_XMLParser_class(){

    { //::CEGUI::XMLParser
        typedef bp::class_< XMLParser_wrapper, bp::bases< CEGUI::PropertySet >, boost::noncopyable > XMLParser_exposer_t;
        XMLParser_exposer_t XMLParser_exposer = XMLParser_exposer_t( "XMLParser", bp::init< >("*!\n\
        \n\
            XMLParser base class constructor.\n\
         *\n") );
        bp::scope XMLParser_scope( XMLParser_exposer );
        { //::CEGUI::XMLParser::cleanup
        
            typedef void ( ::CEGUI::XMLParser::*cleanup_function_type )(  ) ;
            
            XMLParser_exposer.def( 
                "cleanup"
                , cleanup_function_type( &::CEGUI::XMLParser::cleanup )
                , "*!\n\
                    \n\
                        Cleans up the XMLParser module after use.\n\
            \n\
                        Note that this calls the protected abstract method 'cleanupImpl', which should\n\
                        be provided in your implementation to perform any required cleanup.\n\
            \n\
                    @return\n\
                        Nothing.\n\
                     *\n" );
        
        }
        { //::CEGUI::XMLParser::cleanupImpl
        
            typedef void ( XMLParser_wrapper::*cleanupImpl_function_type )(  ) ;
            
            XMLParser_exposer.def( 
                "cleanupImpl"
                , cleanupImpl_function_type( &XMLParser_wrapper::cleanupImpl )
                , "*!\n\
                    \n\
                        abstract method which cleans up the XMLParser after use.\n\
            \n\
                    @return\n\
                        Nothing.\n\
                     *\n" );
        
        }
        { //::CEGUI::XMLParser::getIdentifierString
        
            typedef ::CEGUI::String const & ( ::CEGUI::XMLParser::*getIdentifierString_function_type )(  ) const;
            
            XMLParser_exposer.def( 
                "getIdentifierString"
                , getIdentifierString_function_type( &::CEGUI::XMLParser::getIdentifierString )
                , bp::return_value_policy< bp::copy_const_reference >()
                , "*!\n\
                    \n\
                        Return identification string for the XML parser module.  If the internal id string has\
                        not been\n\
                        set by the XML parser module creator, a generic string of Unknown XML parser will be\
                        returned.\n\
            \n\
                    @return\n\
                        String object holding a string that identifies the XML parser in use.\n\
                    *\n" );
        
        }
        { //::CEGUI::XMLParser::initialise
        
            typedef bool ( ::CEGUI::XMLParser::*initialise_function_type )(  ) ;
            
            XMLParser_exposer.def( 
                "initialise"
                , initialise_function_type( &::CEGUI::XMLParser::initialise )
                , "*!\n\
                    \n\
                        Initialises the XMLParser module ready for use.\n\
            \n\
                        Note that this calls the protected abstract method 'initialiseImpl', which should\n\
                        be provided in your implementation to perform any required initialisation.\n\
            \n\
                    @return\n\
                        - true if the module initialised successfully.\n\
                        - false if the module initialisation failed.\n\
                     *\n" );
        
        }
        { //::CEGUI::XMLParser::initialiseImpl
        
            typedef bool ( XMLParser_wrapper::*initialiseImpl_function_type )(  ) ;
            
            XMLParser_exposer.def( 
                "initialiseImpl"
                , initialiseImpl_function_type( &XMLParser_wrapper::initialiseImpl )
                , "*!\n\
                    \n\
                        abstract method which initialises the XMLParser ready for use.\n\
            \n\
                    @return\n\
                        - true if the module initialised successfully.\n\
                        - false if the module initialisation failed.\n\
                     *\n" );
        
        }
        { //::CEGUI::XMLParser::parseXML
        
            typedef void ( ::CEGUI::XMLParser::*parseXML_function_type )( ::CEGUI::XMLHandler &,::CEGUI::RawDataContainer const &,::CEGUI::String const & ) ;
            
            XMLParser_exposer.def( 
                "parseXML"
                , bp::pure_virtual( parseXML_function_type(&::CEGUI::XMLParser::parseXML) )
                , ( bp::arg("handler"), bp::arg("source"), bp::arg("schemaName") )
                , "*!\n\
                    \n\
                        abstract method which initiates parsing of an XML.\n\
            \n\
                    @param handler\n\
                        XMLHandler based object which will process the XML elements.\n\
            \n\
                    @param source\n\
                        RawDataContainer containing the data to parse\n\
            \n\
                    @param schemaName\n\
                        String object holding the name of the XML schema file to use for validating the XML.\n\
                        Note that whether this is used or not is dependant upon the XMLParser in use.\n\
            \n\
                    @return\n\
                        Nothing.\n\
                     *\n" );
        
        }
        { //::CEGUI::XMLParser::parseXMLFile
        
            typedef void ( ::CEGUI::XMLParser::*parseXMLFile_function_type )( ::CEGUI::XMLHandler &,::CEGUI::String const &,::CEGUI::String const &,::CEGUI::String const & ) ;
            typedef void ( XMLParser_wrapper::*default_parseXMLFile_function_type )( ::CEGUI::XMLHandler &,::CEGUI::String const &,::CEGUI::String const &,::CEGUI::String const & ) ;
            
            XMLParser_exposer.def( 
                "parseXMLFile"
                , parseXMLFile_function_type(&::CEGUI::XMLParser::parseXMLFile)
                , default_parseXMLFile_function_type(&XMLParser_wrapper::default_parseXMLFile)
                , ( bp::arg("handler"), bp::arg("filename"), bp::arg("schemaName"), bp::arg("resourceGroup") ) );
        
        }
        { //::CEGUI::XMLParser::parseXMLString
        
            typedef void ( ::CEGUI::XMLParser::*parseXMLString_function_type )( ::CEGUI::XMLHandler &,::CEGUI::String const &,::CEGUI::String const & ) ;
            typedef void ( XMLParser_wrapper::*default_parseXMLString_function_type )( ::CEGUI::XMLHandler &,::CEGUI::String const &,::CEGUI::String const & ) ;
            
            XMLParser_exposer.def( 
                "parseXMLString"
                , parseXMLString_function_type(&::CEGUI::XMLParser::parseXMLString)
                , default_parseXMLString_function_type(&XMLParser_wrapper::default_parseXMLString)
                , ( bp::arg("handler"), bp::arg("source"), bp::arg("schemaName") ) );
        
        }
    }

}
